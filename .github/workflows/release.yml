# .github/workflows/release.yml

name: Create Plugin Release

on:
  push:
    tags:
      - 'v*' # Triggers on tags like v1.0, v1.2.3

jobs:
  build-and-release:
    name: Build and Release ZXP
    runs-on: ubuntu-latest # Or windows-latest if ZXPSignCmd is easier there

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18' # Or your preferred Node.js version

      - name: Install dependencies (if any for packaging)
        run: |
          if [ -f package-lock.json ] || [ -f yarn.lock ]; then
            npm install
          else
            echo "No lock file found, skipping npm install."
          fi

      - name: Decode .p12 Certificate
        env:
          SIGNING_CERTIFICATE_P12_BASE64: ${{ secrets.SIGNING_CERTIFICATE_P12_BASE64 }}
        run: |
          mkdir -p ./private
          echo $SIGNING_CERTIFICATE_P12_BASE64 | base64 --decode > ./private/certificate.p12
          echo "Certificate decoded to ./private/certificate.p12"

      # --- ZXPSignCmd Setup ---
      - name: Setup ZXPSignCmd
        run: |
          echo "Attempting to download and set up ZXPSignCmd for Linux..."
          ZXPSIGNCMD_DIR="${{ runner.temp }}/zxpsigncmd_tool"
          mkdir -p ${ZXPSIGNCMD_DIR}

          # IMPORTANT: Replace YOUR_URL_TO_ZXPSIGNCMD_LINUX_ARCHIVE with the actual download link.
          # This might be a .zip or .tar.gz file containing ZXPSignCmd for Linux.
          # You need to find this URL from Adobe's developer resources or a trusted source.
          ZXPSIGNCMD_ARCHIVE_URL="YOUR_URL_TO_ZXPSIGNCMD_LINUX_ARCHIVE" # e.g., https://example.com/path/to/ZXPSignCmd_linux.zip

          if [ "${ZXPSIGNCMD_ARCHIVE_URL}" == "YOUR_URL_TO_ZXPSIGNCMD_LINUX_ARCHIVE" ]; then
            echo "Error: Placeholder URL for ZXPSignCmd archive is still present. Please update the workflow."
            echo "Skipping ZXPSignCmd download. The build will likely fail."
            # exit 1 # Optionally fail the build here if URL is not set
          else
            echo "Downloading ZXPSignCmd from ${ZXPSIGNCMD_ARCHIVE_URL}..."
            curl -L -o "${ZXPSIGNCMD_DIR}/ZXPSignCmd_archive" "${ZXPSIGNCMD_ARCHIVE_URL}"

            echo "Extracting ZXPSignCmd..."
            # Adjust extraction based on archive type
            if [[ "${ZXPSIGNCMD_ARCHIVE_URL}" == *.zip ]]; then
              unzip "${ZXPSIGNCMD_DIR}/ZXPSignCmd_archive" -d "${ZXPSIGNCMD_DIR}"
            elif [[ "${ZXPSIGNCMD_ARCHIVE_URL}" == *.tar.gz ]]; then
              tar -xzf "${ZXPSIGNCMD_DIR}/ZXPSignCmd_archive" -C "${ZXPSIGNCMD_DIR}"
            else
              echo "Unsupported archive type for ZXPSignCmd. Please use .zip or .tar.gz or adjust script."
              # exit 1 # Optionally fail
            fi

            # Assuming ZXPSignCmd executable is now in ${ZXPSIGNCMD_DIR} or a subdirectory
            # Find the executable - this path might need adjustment based on the archive structure
            ZXPSIGNCMD_EXEC_PATH=$(find "${ZXPSIGNCMD_DIR}" -name "ZXPSignCmd" -type f -executable 2>/dev/null || find "${ZXPSIGNCMD_DIR}" -name "ZXPSignCmd" -type f 2>/dev/null)

            if [ -z "${ZXPSIGNCMD_EXEC_PATH}" ]; then
                echo "Error: ZXPSignCmd executable not found after extraction in ${ZXPSIGNCMD_DIR}."
                ls -R ${ZXPSIGNCMD_DIR} # List contents for debugging
                # exit 1 # Optionally fail
            else
                echo "ZXPSignCmd found at ${ZXPSIGNCMD_EXEC_PATH}"
                chmod +x "${ZXPSIGNCMD_EXEC_PATH}" # Ensure it's executable
                # Add the directory of ZXPSignCmd to GITHUB_PATH
                echo "$(dirname "${ZXPSIGNCMD_EXEC_PATH}")" >> $GITHUB_PATH
                echo "ZXPSignCmd directory added to PATH."
                ZXPSignCmd -help # Test if it runs
            fi
          fi

      - name: Package and Sign ZXP
        env:
          SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.SIGNING_CERTIFICATE_PASSWORD }}
          TAG_NAME: ${{ github.ref_name }}
          PLUGIN_ID: "com.gishant.eccouncilplugin"
        run: |
          PLUGIN_VERSION="${TAG_NAME#v}"
          SOURCE_FOLDER="./"
          OUTPUT_ZXP_FILENAME="${PLUGIN_ID}.${PLUGIN_VERSION}.zxp"
          DIST_FOLDER="./dist"
          OUTPUT_ZXP_PATH="${DIST_FOLDER}/${OUTPUT_ZXP_FILENAME}"
          CERTIFICATE_PATH="./private/certificate.p12"

          mkdir -p ${DIST_FOLDER}

          echo "Packaging plugin: ${PLUGIN_ID}, Version: ${PLUGIN_VERSION}"
          echo "Source: ${SOURCE_FOLDER}, Output: ${OUTPUT_ZXP_PATH}, Cert: ${CERTIFICATE_PATH}"

          # ZXPSignCmd should now be in PATH due to the previous step
          ZXPSIGNCMD_EXEC="ZXPSignCmd"

          TIMESTAMP_SERVER="http://timestamp.adobe.com/tsa"

          echo "Running ${ZXPSIGNCMD_EXEC}..."
          ${ZXPSIGNCMD_EXEC} -sign "${SOURCE_FOLDER}" "${OUTPUT_ZXP_PATH}" "${CERTIFICATE_PATH}" "${SIGNING_CERTIFICATE_PASSWORD}" -tsa "${TIMESTAMP_SERVER}"

          if [ ! -f "${OUTPUT_ZXP_PATH}" ]; then
            echo "Error: ZXP file was not created at ${OUTPUT_ZXP_PATH}!"
            exit 1
          fi
          echo "ZXP file created successfully."
          ls -l ${DIST_FOLDER}

      - name: Set ZXP Filename for Upload
        id: set_zxp_filename
        env:
            PLUGIN_ID: "com.gishant.eccouncilplugin"
            TAG_NAME: ${{ github.ref_name }}
        run: |
          PLUGIN_VERSION="${TAG_NAME#v}"
          ZXP_FILENAME="${PLUGIN_ID}.${PLUGIN_VERSION}.zxp"
          echo "ZXP_FILENAME=${ZXP_FILENAME}" >> $GITHUB_ENV
          # The ::set-output command is deprecated for GITHUB_ENV
          # GITHUB_ENV is the preferred way for subsequent steps in the same job.
          # For cross-job outputs, use 'outputs' at the job level.

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Plugin Version ${{ github.ref_name }}
          body: |
            Automated release for Video Automation Hub version ${{ github.ref_name }}.
            Download the ZXP file below to install the plugin.
          draft: false
          prerelease: false

      - name: Upload Release Asset (ZXP)
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # ZXP_FILENAME is now available from GITHUB_ENV set in the 'Set ZXP Filename for Upload' step
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./dist/${{ env.ZXP_FILENAME }}
          asset_name: ${{ env.ZXP_FILENAME }}
          asset_content_type: application/octet-stream

      - name: Clean up decoded certificate
        if: always()
        run: |
          rm -f ./private/certificate.p12
          echo "Cleaned up decoded certificate."
