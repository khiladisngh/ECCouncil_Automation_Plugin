# .github/workflows/release.yml

name: Create Plugin Release

on:
  push:
    tags:
      - 'v*' # Triggers on tags like v1.0, v1.2.3

jobs:
  build-and-release:
    name: Build and Release ZXP
    runs-on: ubuntu-latest # Or windows-latest if ZXPSignCmd is easier there

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18' # Or your preferred Node.js version

      - name: Install dependencies (if any for packaging)
        # This step is if you have npm packages needed for any pre-packaging steps
        # For ZXPSignCmd directly, this might not be strictly needed unless a wrapper is used.
        run: |
          if [ -f package-lock.json ] || [ -f yarn.lock ]; then
            npm install
          else
            echo "No lock file found, skipping npm install."
          fi

      - name: Decode .p12 Certificate
        env:
          SIGNING_CERTIFICATE_P12_BASE64: ${{ secrets.SIGNING_CERTIFICATE_P12_BASE64 }}
        run: |
          mkdir -p ./private
          echo $SIGNING_CERTIFICATE_P12_BASE64 | base64 --decode > ./private/certificate.p12
          echo "Certificate decoded to ./private/certificate.p12"
        # Ensure 'private/' is in your .gitignore

      # --- ZXPSignCmd Setup ---
      - name: Setup ZXPSignCmd
        run: |
          echo "ZXPSignCmd setup step:"
          echo "1. Ensure ZXPSignCmd is available in the PATH or specify its full path in the next step."
          echo "2. For CI, consider using a GitHub Marketplace Action that sets up ZXPSignCmd."
          echo "3. Alternatively, you can download and extract ZXPSignCmd here:"
          echo "   Example (conceptual - paths and URLs will vary):"
          echo "   # mkdir -p ${{ runner.temp }}/zxpsigncmd_tool"
          echo "   # curl -L -o ${{ runner.temp }}/ZXPSignCmd.zip YOUR_URL_TO_ZXPSIGNCMD_ARCHIVE"
          echo "   # unzip ${{ runner.temp }}/ZXPSignCmd.zip -d ${{ runner.temp }}/zxpsigncmd_tool"
          echo "   # echo '${{ runner.temp }}/zxpsigncmd_tool' >> $GITHUB_PATH # Add to PATH"
          echo "Using 'ZXPSignCmd' assuming it's in PATH or you will adjust the command below."
          # On Windows, it might be ZXPSignCmd.exe
          # On macOS/Linux, it might be just ZXPSignCmd after chmod +x

      - name: Package and Sign ZXP
        env:
          SIGNING_CERTIFICATE_PASSWORD: ${{ secrets.SIGNING_CERTIFICATE_PASSWORD }}
          TAG_NAME: ${{ github.ref_name }} # Gets the tag name, e.g., v1.0.0
          # Fetch ExtensionBundleId from manifest.xml to ensure consistency.
          # This requires an XML parser or a simple grep/sed.
          # For simplicity, we'll use the known ID, but parsing is more robust.
          PLUGIN_ID: "com.gishant.videoautomationhub" # As per your manifest.xml
        run: |
          PLUGIN_VERSION="${TAG_NAME#v}" # Remove 'v' prefix from tag for version

          SOURCE_FOLDER="./" # Root of your plugin project
          # Define the output ZXP filename structure
          OUTPUT_ZXP_FILENAME="${PLUGIN_ID}.${PLUGIN_VERSION}.zxp"
          DIST_FOLDER="./dist"
          OUTPUT_ZXP_PATH="${DIST_FOLDER}/${OUTPUT_ZXP_FILENAME}"
          CERTIFICATE_PATH="./private/certificate.p12"

          mkdir -p ${DIST_FOLDER} # Create dist directory if it doesn't exist

          echo "Packaging plugin: ${PLUGIN_ID}"
          echo "Version: ${PLUGIN_VERSION}"
          echo "Source folder: ${SOURCE_FOLDER}"
          echo "Output ZXP: ${OUTPUT_ZXP_PATH}"
          echo "Certificate: ${CERTIFICATE_PATH}"

          # --- Adjust the ZXPSignCmd executable name/path as needed ---
          # If ZXPSignCmd is in PATH:
          ZXPSIGNCMD_EXEC="ZXPSignCmd"
          # If it's downloaded to a specific location, e.g., ${{ runner.temp }}/zxpsigncmd_tool/ZXPSignCmd
          # ZXPSIGNCMD_EXEC="${{ runner.temp }}/zxpsigncmd_tool/ZXPSignCmd"
          # On Windows, it might be "ZXPSignCmd.exe"

          # The -tsa option adds a timestamp from a Time Stamping Authority.
          # This is good practice as it proves the signature was valid at the time of signing,
          # even if the signing certificate expires later.
          # Adobe's recommended TSA: http://timestamp.adobe.com/tsa
          # Some common free TSAs: http://sha256timestamp.ws.symantec.com/sha256/timestamp or http://timestamp.digicert.com
          # If a TSA is unavailable or causes issues, you can remove the -tsa flag and its URL.
          TIMESTAMP_SERVER="http://timestamp.adobe.com/tsa"

          echo "Running ZXPSignCmd..."
          ${ZXPSIGNCMD_EXEC} -sign "${SOURCE_FOLDER}" "${OUTPUT_ZXP_PATH}" "${CERTIFICATE_PATH}" "${SIGNING_CERTIFICATE_PASSWORD}" -tsa "${TIMESTAMP_SERVER}"

          echo "ZXP file should be created at ${OUTPUT_ZXP_PATH}"
          # Add a check to see if the file was actually created
          if [ ! -f "${OUTPUT_ZXP_PATH}" ]; then
            echo "Error: ZXP file was not created!"
            exit 1
          fi
          ls -l ${DIST_FOLDER} # List contents of dist to verify

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Plugin Version ${{ github.ref_name }}
          body: |
            Automated release for Video Automation Hub version ${{ github.ref_name }}.
            Download the ZXP file below to install the plugin.
          draft: false
          prerelease: false

      - name: Upload Release Asset (ZXP)
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PLUGIN_ID: "com.gishant.videoautomationhub" #
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          # Construct asset path and name using the same logic as in the packaging step
          asset_path: ./dist/${{ env.PLUGIN_ID }}_${{ github.ref_name }}v.zxp # Path to the ZXP file (adjust if needed)
          asset_name: ${{ env.PLUGIN_ID }}_${{ github.ref_name }}v.zxp # Name of the asset in the release
          asset_content_type: application/octet-stream

      - name: Clean up decoded certificate
        if: always() # Always run this step
        run: |
          rm -f ./private/certificate.p12
          echo "Cleaned up decoded certificate."
